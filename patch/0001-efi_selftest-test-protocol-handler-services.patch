From c5712885c28bedb39ed49d39ff091110be6d69c0 Mon Sep 17 00:00:00 2001
From: Heinrich Schuchardt <xypron.glpk@gmx.de>
Date: Sun, 17 Sep 2017 17:49:19 +0200
Subject: [PATCH 1/1] efi_selftest: test protocol handler services

Signed-off-by: Heinrich Schuchardt <xypron.glpk@gmx.de>
---
 lib/efi_selftest/Makefile                        |   3 +
 lib/efi_selftest/efi_selftest_protocolservices.c | 166 +++++++++++++++++++++++
 2 files changed, 169 insertions(+)
 create mode 100644 lib/efi_selftest/efi_selftest_protocolservices.c

diff --git a/lib/efi_selftest/Makefile b/lib/efi_selftest/Makefile
index 30f1960933..f7635530b5 100644
--- a/lib/efi_selftest/Makefile
+++ b/lib/efi_selftest/Makefile
@@ -15,6 +15,8 @@ CFLAGS_efi_selftest_events.o := $(CFLAGS_EFI)
 CFLAGS_REMOVE_efi_selftest_events.o := $(CFLAGS_NON_EFI)
 CFLAGS_efi_selftest_exitbootservices.o := $(CFLAGS_EFI)
 CFLAGS_REMOVE_efi_selftest_exitbootservices.o := $(CFLAGS_NON_EFI)
+CFLAGS_efi_selftest_protocolservices.o := $(CFLAGS_EFI)
+CFLAGS_REMOVE_efi_selftest_protocolservices.o := $(CFLAGS_NON_EFI)
 CFLAGS_efi_selftest_tpl.o := $(CFLAGS_EFI)
 CFLAGS_REMOVE_efi_selftest_tpl.o := $(CFLAGS_NON_EFI)
 
@@ -23,4 +25,5 @@ efi_selftest.o \
 efi_selftest_console.o \
 efi_selftest_events.o \
 efi_selftest_exitbootservices.o \
+efi_selftest_protocolservices.o \
 efi_selftest_tpl.o
diff --git a/lib/efi_selftest/efi_selftest_protocolservices.c b/lib/efi_selftest/efi_selftest_protocolservices.c
new file mode 100644
index 0000000000..0b6ac7ea2b
--- /dev/null
+++ b/lib/efi_selftest/efi_selftest_protocolservices.c
@@ -0,0 +1,166 @@
+/*
+ * efi_selftest_events
+ *
+ * Copyright (c) 2017 Heinrich Schuchardt <xypron.glpk@gmx.de>
+ *
+ * SPDX-License-Identifier:     GPL-2.0+
+ *
+ * This unit test checks the following protocol services:
+ */
+
+#include <efi_selftest.h>
+
+static struct efi_boot_services *boottime;
+
+static efi_handle_t handle1;
+static efi_handle_t handle2;
+
+struct interface {
+	void (EFIAPI * inc)(void);
+};
+
+static efi_guid_t guid1 =
+	EFI_GUID(0x2e7ca819, 0x21d3, 0x0a3a,
+		 0xf7, 0x91, 0x82, 0x1f, 0x7a, 0x83, 0x67, 0xaf);
+static unsigned int counter1;
+void EFIAPI inc1(void)
+{
+	++counter1;
+}
+static struct interface interface1 = {
+	inc1,
+};
+static struct interface interface4 = {
+	inc1,
+};
+
+static efi_guid_t guid2 =
+	EFI_GUID(0xf909f2bb, 0x90a8, 0x0d77,
+		 0x94, 0x0c, 0x3e, 0xa8, 0xea, 0x38, 0xd6, 0x6f);
+static unsigned int counter2;
+void EFIAPI inc2(void)
+{
+	++counter2;
+}
+static struct interface interface2 = {
+	inc2,
+};
+
+static efi_guid_t guid3 =
+	EFI_GUID(0x06d641a3, 0xf4e7, 0xe0c9,
+		 0xe7, 0x8d, 0x41, 0x2d, 0x72, 0xa6, 0xb1, 0x24);
+static unsigned int counter3;
+void EFIAPI inc3(void)
+{
+	++counter3;
+}
+static struct interface interface3 = {
+	inc3,
+};
+
+
+/*
+ * Setup unit test.
+ *
+ * Create two handles and install two out of three protocol interfaces on each
+ * of them.
+ *
+ * @handle:	handle of the loaded image
+ * @systable:	system table
+ */
+static int setup(const efi_handle_t img_handle,
+		 const struct efi_system_table *systable)
+{
+	efi_status_t ret;
+	efi_handle_t handle;
+
+	boottime = systable->boottime;
+
+	ret = boottime->install_protocol_interface(&handle1, &guid3, EFI_NATIVE_INTERFACE, &interface3);
+	if (ret != EFI_SUCCESS) {
+		efi_st_error("Failed to install protocol\n");
+		return 1;
+	}
+	if (!handle1) {
+		efi_st_error("Failed to create handle\n");
+		return 1;
+	}
+	handle = handle1;
+	ret = boottime->install_protocol_interface(&handle1, &guid1, EFI_NATIVE_INTERFACE, &interface1);
+	if (ret != EFI_SUCCESS) {
+		efi_st_error("Failed to install protocol\n");
+		return 1;
+	}
+	if (handle != handle1) {
+		efi_st_error("Failed to use handle\n");
+		return 1;
+	}
+	ret = boottime->install_protocol_interface(&handle2, &guid1, EFI_NATIVE_INTERFACE, &interface4);
+	if (ret != EFI_SUCCESS) {
+		efi_st_error("Failed to install protocol\n");
+		return 1;
+	}
+	if (!handle2 || handle1 == handle2) {
+		efi_st_error("Failed to create handle\n");
+		return 1;
+	}
+	handle = handle2;
+	ret =boottime->install_protocol_interface(&handle2, &guid2, EFI_NATIVE_INTERFACE, &interface2);
+	if (ret != EFI_SUCCESS) {
+		efi_st_error("Failed to install protocol\n");
+		return 1;
+	}
+	if (handle != handle2) {
+		efi_st_error("Failed to use handle\n");
+		return 1;
+	}
+
+	return 0;
+}
+
+/*
+ * Tear down unit test.
+ *
+ */
+static int teardown(void)
+{
+	return 0;
+}
+
+/*
+ * Execute unit test.
+ *
+ */
+static int execute(void)
+{
+	struct interface *interface;
+	efi_status_t ret;
+	efi_handle_t *buffer;
+	UINTN count;
+
+	ret = boottime->locate_handle_buffer(ALL_HANDLES, NULL, NULL, &count, buffer);
+	if (ret != EFI_SUCCESS) {
+		efi_st_error("Failed to locate all handles\n");
+		return 1;
+	}
+
+	ret = boottime->locate_protocol(&guid1, NULL, (void **) &interface);
+	if (ret != EFI_SUCCESS) {
+		efi_st_error("Failed to locate protocol\n");
+		return 1;
+	}
+	if (interface != &interface1 && interface != &interface4) {
+		efi_st_error("Failed to locate protocol\n");
+		return 1;
+	}
+
+	return 0;
+}
+
+EFI_UNIT_TEST(protserv) = {
+	.name = "protocol services",
+	.phase = EFI_EXECUTE_BEFORE_BOOTTIME_EXIT,
+	.setup = setup,
+	.execute = execute,
+	.teardown = teardown,
+};
-- 
2.11.0

