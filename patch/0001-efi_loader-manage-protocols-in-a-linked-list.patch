From 785dbb6ccd50cf9e2d60898d1eaf04b174bf3cac Mon Sep 17 00:00:00 2001
From: Heinrich Schuchardt <xypron.glpk@gmx.de>
Date: Sun, 22 Oct 2017 10:16:41 +0200
Subject: [PATCH 1/1] efi_loader: manage protocols in a linked list

Signed-off-by: Heinrich Schuchardt <xypron.glpk@gmx.de>
---
 include/efi_loader.h          |  23 +--
 lib/efi_loader/efi_boottime.c | 319 +++++++++++++++++++++---------------------
 2 files changed, 176 insertions(+), 166 deletions(-)

diff --git a/include/efi_loader.h b/include/efi_loader.h
index 2bcca3dfd8..364a9b0a20 100644
--- a/include/efi_loader.h
+++ b/include/efi_loader.h
@@ -101,6 +101,8 @@ extern unsigned int __efi_runtime_rel_start, __efi_runtime_rel_stop;
  * interface (usually a struct with callback functions), this struct maps the
  * protocol GUID to the respective protocol interface */
 struct efi_handler {
+	/* Link to the list of protocols of a handle */
+	struct list_head link;
 	const efi_guid_t *guid;
 	void *protocol_interface;
 };
@@ -115,20 +117,12 @@ struct efi_handler {
 struct efi_object {
 	/* Every UEFI object is part of a global object list */
 	struct list_head link;
-	/* We support up to 16 "protocols" an object can be accessed through */
-	struct efi_handler protocols[16];
+	/* The list of protocols */
+	struct list_head protocols;
 	/* The object spawner can either use this for data or as identifier */
 	void *handle;
 };
 
-#define EFI_PROTOCOL_OBJECT(_guid, _protocol) (struct efi_object){	\
-	.protocols = {{							\
-		.guid = &(_guid),	 				\
-		.protocol_interface = (void *)(_protocol), 		\
-	}},								\
-	.handle = (void *)(_protocol),					\
-}
-
 /**
  * struct efi_event
  *
@@ -194,6 +188,15 @@ void efi_set_bootdev(const char *dev, const char *devnr, const char *path);
 efi_status_t efi_create_handle(void **handle);
 /* Call this to validate a handle and find the EFI object for it */
 struct efi_object *efi_search_obj(void *handle);
+/* Find a protocol on a handle */
+efi_status_t efi_search_protocol(void *handle, const efi_guid_t *protocol_guid,
+				 struct efi_handler **handler);
+/* Install new protocol on a handle */
+efi_status_t efi_add_protocol(void *handle, const efi_guid_t *protocol,
+			      void *protocol_interface);
+/* Delete protocol on a handle */
+efi_status_t efi_remove_protocol(void *handle, const efi_guid_t *protocol,
+				 void *protocol_interface);
 /* Call this to create an event */
 efi_status_t efi_create_event(uint32_t type, efi_uintn_t notify_tpl,
 			      void (EFIAPI *notify_function) (
diff --git a/lib/efi_loader/efi_boottime.c b/lib/efi_loader/efi_boottime.c
index bdbed32656..b245b31f61 100644
--- a/lib/efi_loader/efi_boottime.c
+++ b/lib/efi_loader/efi_boottime.c
@@ -696,6 +696,92 @@ struct efi_object *efi_search_obj(void *handle)
 	return NULL;
 }
 
+/*
+ * Find a protocol on a handle.
+ *
+ * @handle		handle
+ * @protocol_guid	GUID of the protocol
+ * @handler		reference to the protocol
+ * @return		status code
+ */
+efi_status_t efi_search_protocol(void *handle, const efi_guid_t *protocol_guid,
+				 struct efi_handler **handler)
+{
+	struct efi_object *efiobj;
+	struct list_head *lhandle;
+
+	if (!handle || !protocol_guid)
+		return EFI_INVALID_PARAMETER;
+	efiobj = efi_search_obj(handle);
+	if (!efiobj)
+		return EFI_INVALID_PARAMETER;
+	list_for_each(lhandle, &efiobj->protocols) {
+		struct efi_handler *protocol;
+
+		protocol = list_entry(lhandle, struct efi_handler, link);
+		if (!guidcmp(protocol->guid, protocol_guid)) {
+			if (handler)
+				*handler = protocol;
+			return EFI_SUCCESS;
+		}
+	}
+	return EFI_NOT_FOUND;
+}
+
+/*
+ * Install new protocol on a handle.
+ *
+ * @handle			handle on which the protocol shall be installed
+ * @protocol			GUID of the protocol to be installed
+ * @protocol_interface		interface of the protocol implementation
+ * @return			status code
+ */
+efi_status_t efi_add_protocol(void *handle, const efi_guid_t *protocol,
+			      void *protocol_interface)
+{
+	struct efi_object *efiobj;
+	struct efi_handler *handler;
+	efi_status_t ret;
+
+	efiobj = efi_search_obj(handle);
+	if (!efiobj)
+		return EFI_INVALID_PARAMETER;
+	ret = efi_search_protocol(handle, protocol, NULL);
+	if (ret != EFI_NOT_FOUND)
+		return EFI_INVALID_PARAMETER;
+	handler = calloc(1, sizeof(struct efi_handler));
+	if (!handler)
+		return EFI_OUT_OF_RESOURCES;
+	handler->guid = protocol;
+	handler->protocol_interface = protocol_interface;
+	list_add_tail(&handler->link, &efiobj->protocols);
+	return EFI_SUCCESS;
+}
+
+/*
+ * Delete protocol on a handle.
+ *
+ * @handle			handle on which the protocol shall be installed
+ * @protocol			GUID of the protocol to be installed
+ * @protocol_interface		interface of the protocol implementation
+ * @return			status code
+ */
+efi_status_t efi_remove_protocol(void *handle, const efi_guid_t *protocol,
+				 void *protocol_interface)
+{
+	struct efi_handler *handler;
+	efi_status_t ret;
+
+	ret = efi_search_protocol(handle, protocol, &handler);
+	if (ret != EFI_SUCCESS)
+		return ret;
+	if (guidcmp(handler->guid, protocol))
+		return EFI_INVALID_PARAMETER;
+	list_del(&handler->link);
+	free(handler);
+	return EFI_SUCCESS;
+}
+
 /*
  * Install protocol interface.
  *
@@ -714,8 +800,6 @@ static efi_status_t EFIAPI efi_install_protocol_interface(
 			void **handle, const efi_guid_t *protocol,
 			int protocol_interface_type, void *protocol_interface)
 {
-	struct list_head *lhandle;
-	int i;
 	efi_status_t r;
 
 	EFI_ENTRY("%p, %pUl, %d, %p", handle, protocol, protocol_interface_type,
@@ -733,40 +817,8 @@ static efi_status_t EFIAPI efi_install_protocol_interface(
 		if (r != EFI_SUCCESS)
 			goto out;
 	}
-	/* Find object. */
-	list_for_each(lhandle, &efi_obj_list) {
-		struct efi_object *efiobj;
-		efiobj = list_entry(lhandle, struct efi_object, link);
-
-		if (efiobj->handle != *handle)
-			continue;
-		/* Check if protocol is already installed on the handle. */
-		for (i = 0; i < ARRAY_SIZE(efiobj->protocols); i++) {
-			struct efi_handler *handler = &efiobj->protocols[i];
-
-			if (!handler->guid)
-				continue;
-			if (!guidcmp(handler->guid, protocol)) {
-				r = EFI_INVALID_PARAMETER;
-				goto out;
-			}
-		}
-		/* Install protocol in first empty slot. */
-		for (i = 0; i < ARRAY_SIZE(efiobj->protocols); i++) {
-			struct efi_handler *handler = &efiobj->protocols[i];
-
-			if (handler->guid)
-				continue;
-
-			handler->guid = protocol;
-			handler->protocol_interface = protocol_interface;
-			r = EFI_SUCCESS;
-			goto out;
-		}
-		r = EFI_OUT_OF_RESOURCES;
-		goto out;
-	}
-	r = EFI_INVALID_PARAMETER;
+	/* Add new protocol */
+	r = efi_add_protocol(handle, protocol, protocol_interface);
 out:
 	return EFI_EXIT(r);
 }
@@ -810,9 +862,8 @@ static efi_status_t EFIAPI efi_uninstall_protocol_interface(
 				void *handle, const efi_guid_t *protocol,
 				void *protocol_interface)
 {
-	struct list_head *lhandle;
-	int i;
-	efi_status_t r = EFI_NOT_FOUND;
+	struct efi_handler *handler;
+	efi_status_t r;
 
 	EFI_ENTRY("%p, %pUl, %p", handle, protocol, protocol_interface);
 
@@ -821,31 +872,16 @@ static efi_status_t EFIAPI efi_uninstall_protocol_interface(
 		goto out;
 	}
 
-	list_for_each(lhandle, &efi_obj_list) {
-		struct efi_object *efiobj;
-		efiobj = list_entry(lhandle, struct efi_object, link);
-
-		if (efiobj->handle != handle)
-			continue;
+	r = efi_search_protocol(handle, protocol, &handler);
+	if (r != EFI_SUCCESS)
+		goto out;
 
-		for (i = 0; i < ARRAY_SIZE(efiobj->protocols); i++) {
-			struct efi_handler *handler = &efiobj->protocols[i];
-			const efi_guid_t *hprotocol = handler->guid;
-
-			if (!hprotocol)
-				continue;
-			if (!guidcmp(hprotocol, protocol)) {
-				if (handler->protocol_interface) {
-					r = EFI_ACCESS_DENIED;
-				} else {
-					handler->guid = 0;
-					r = EFI_SUCCESS;
-				}
-				goto out;
-			}
-		}
+	if (handler->protocol_interface) {
+		r = EFI_ACCESS_DENIED;
+		goto out;
 	}
 
+	r = efi_remove_protocol(handle, protocol, protocol_interface);
 out:
 	return EFI_EXIT(r);
 }
@@ -887,7 +923,7 @@ static int efi_search(enum efi_locate_search_type search_type,
 		      const efi_guid_t *protocol, void *search_key,
 		      struct efi_object *efiobj)
 {
-	int i;
+	efi_status_t ret;
 
 	switch (search_type) {
 	case ALL_HANDLES:
@@ -896,14 +932,9 @@ static int efi_search(enum efi_locate_search_type search_type,
 		/* RegisterProtocolNotify is not implemented yet */
 		return -1;
 	case BY_PROTOCOL:
-		for (i = 0; i < ARRAY_SIZE(efiobj->protocols); i++) {
-			const efi_guid_t *guid = efiobj->protocols[i].guid;
-			if (guid && !guidcmp(guid, protocol))
-				return 0;
-		}
-		return -1;
+		ret = efi_search_protocol(efiobj->handle, protocol, NULL);
+		return (ret != EFI_SUCCESS);
 	}
-
 	return -1;
 }
 
@@ -1116,34 +1147,45 @@ void efi_setup_loaded_image(struct efi_loaded_image *info, struct efi_object *ob
 			    struct efi_device_path *device_path,
 			    struct efi_device_path *file_path)
 {
+	efi_status_t ret;
+
 	obj->handle = info;
 
+	info->file_path = file_path;
+	if (device_path)
+		info->device_handle = efi_dp_find_obj(device_path, NULL);
+
+	list_add_tail(&obj->link, &efi_obj_list);
+
 	/*
 	 * When asking for the device path interface, return
 	 * bootefi_device_path
 	 */
-	obj->protocols[0].guid = &efi_guid_device_path;
-	obj->protocols[0].protocol_interface = device_path;
+	ret = efi_add_protocol(obj->handle, &efi_guid_device_path, device_path);
+	if (ret != EFI_SUCCESS)
+		goto failure;
 
 	/*
 	 * When asking for the loaded_image interface, just
 	 * return handle which points to loaded_image_info
 	 */
-	obj->protocols[1].guid = &efi_guid_loaded_image;
-	obj->protocols[1].protocol_interface = info;
-
-	obj->protocols[2].guid = &efi_guid_console_control;
-	obj->protocols[2].protocol_interface = (void *)&efi_console_control;
-
-	obj->protocols[3].guid = &efi_guid_device_path_to_text_protocol;
-	obj->protocols[3].protocol_interface =
-		(void *)&efi_device_path_to_text;
+	ret = efi_add_protocol(obj->handle, &efi_guid_loaded_image, info);
+	if (ret != EFI_SUCCESS)
+		goto failure;
 
-	info->file_path = file_path;
-	if (device_path)
-		info->device_handle = efi_dp_find_obj(device_path, NULL);
+	ret = efi_add_protocol(obj->handle, &efi_guid_console_control,
+			       (void *)&efi_console_control);
+	if (ret != EFI_SUCCESS)
+		goto failure;
 
-	list_add_tail(&obj->link, &efi_obj_list);
+	ret = efi_add_protocol(obj->handle,
+			       &efi_guid_device_path_to_text_protocol,
+			       (void *)&efi_device_path_to_text);
+	if (ret != EFI_SUCCESS)
+		goto failure;
+	return;
+failure:
+	printf("ERROR: Failure to install protocol for loaded image\n");
 }
 
 /*
@@ -1593,8 +1635,7 @@ static efi_status_t EFIAPI efi_protocols_per_handle(void *handle,
 {
 	unsigned long buffer_size;
 	struct efi_object *efiobj;
-	unsigned long i, j;
-	struct list_head *lhandle;
+	struct list_head *protocol_handle;
 	efi_status_t r;
 
 	EFI_ENTRY("%p, %p, %p", handle, protocol_buffer,
@@ -1605,36 +1646,32 @@ static efi_status_t EFIAPI efi_protocols_per_handle(void *handle,
 
 	*protocol_buffer = NULL;
 	*protocol_buffer_count = 0;
-	list_for_each(lhandle, &efi_obj_list) {
-		efiobj = list_entry(lhandle, struct efi_object, link);
 
-		if (efiobj->handle != handle)
-			continue;
+	efiobj = efi_search_obj(handle);
+	if (!efiobj)
+		return EFI_EXIT(EFI_INVALID_PARAMETER);
 
-		/* Count protocols */
-		for (i = 0; i < ARRAY_SIZE(efiobj->protocols); i++) {
-			if (efiobj->protocols[i].guid)
-				++*protocol_buffer_count;
-		}
-		/* Copy guids */
-		if (*protocol_buffer_count) {
-			buffer_size = sizeof(efi_guid_t *) *
-					*protocol_buffer_count;
-			r = efi_allocate_pool(EFI_ALLOCATE_ANY_PAGES,
-					      buffer_size,
-					      (void **)protocol_buffer);
-			if (r != EFI_SUCCESS)
-				return EFI_EXIT(r);
-			j = 0;
-			for (i = 0; i < ARRAY_SIZE(efiobj->protocols); ++i) {
-				if (efiobj->protocols[i].guid) {
-					(*protocol_buffer)[j] = (void *)
-						efiobj->protocols[i].guid;
-					++j;
-				}
-			}
+	/* Count protocols */
+	list_for_each(protocol_handle, &efiobj->protocols)
+		++*protocol_buffer_count;
+
+	/* Copy guids */
+	if (*protocol_buffer_count) {
+		size_t j = 0;
+
+		buffer_size = sizeof(efi_guid_t *) * *protocol_buffer_count;
+		r = efi_allocate_pool(EFI_ALLOCATE_ANY_PAGES, buffer_size,
+				      (void **)protocol_buffer);
+		if (r != EFI_SUCCESS)
+			return EFI_EXIT(r);
+		list_for_each(protocol_handle, &efiobj->protocols) {
+			struct efi_handler *protocol;
+
+			protocol = list_entry(protocol_handle,
+					      struct efi_handler, link);
+			(*protocol_buffer)[j] = (void *)protocol->guid;
+			++j;
 		}
-		break;
 	}
 
 	return EFI_EXIT(EFI_SUCCESS);
@@ -1704,29 +1741,23 @@ static efi_status_t EFIAPI efi_locate_protocol(const efi_guid_t *protocol,
 					       void **protocol_interface)
 {
 	struct list_head *lhandle;
-	int i;
+	efi_status_t ret;
 
 	EFI_ENTRY("%pUl, %p, %p", protocol, registration, protocol_interface);
 
 	if (!protocol || !protocol_interface)
 		return EFI_EXIT(EFI_INVALID_PARAMETER);
 
-	EFI_PRINT_GUID("protocol", protocol);
-
 	list_for_each(lhandle, &efi_obj_list) {
 		struct efi_object *efiobj;
+		struct efi_handler *handler;
 
 		efiobj = list_entry(lhandle, struct efi_object, link);
-		for (i = 0; i < ARRAY_SIZE(efiobj->protocols); i++) {
-			struct efi_handler *handler = &efiobj->protocols[i];
-
-			if (!handler->guid)
-				continue;
-			if (!guidcmp(handler->guid, protocol)) {
-				*protocol_interface =
-					handler->protocol_interface;
-				return EFI_EXIT(EFI_SUCCESS);
-			}
+
+		ret = efi_search_protocol(efiobj->handle, protocol, &handler);
+		if (ret == EFI_SUCCESS) {
+			*protocol_interface = handler->protocol_interface;
+			return EFI_EXIT(EFI_SUCCESS);
 		}
 	}
 	*protocol_interface = NULL;
@@ -1888,8 +1919,7 @@ static efi_status_t EFIAPI efi_open_protocol(
 			void **protocol_interface, void *agent_handle,
 			void *controller_handle, uint32_t attributes)
 {
-	struct list_head *lhandle;
-	int i;
+	struct efi_handler *handler;
 	efi_status_t r = EFI_INVALID_PARAMETER;
 
 	EFI_ENTRY("%p, %pUl, %p, %p, %p, 0x%x", handle, protocol,
@@ -1902,8 +1932,6 @@ static efi_status_t EFIAPI efi_open_protocol(
 		goto out;
 	}
 
-	EFI_PRINT_GUID("protocol", protocol);
-
 	switch (attributes) {
 	case EFI_OPEN_PROTOCOL_BY_HANDLE_PROTOCOL:
 	case EFI_OPEN_PROTOCOL_GET_PROTOCOL:
@@ -1924,33 +1952,12 @@ static efi_status_t EFIAPI efi_open_protocol(
 		goto out;
 	}
 
-	list_for_each(lhandle, &efi_obj_list) {
-		struct efi_object *efiobj;
-		efiobj = list_entry(lhandle, struct efi_object, link);
-
-		if (efiobj->handle != handle)
-			continue;
-
-		for (i = 0; i < ARRAY_SIZE(efiobj->protocols); i++) {
-			struct efi_handler *handler = &efiobj->protocols[i];
-			const efi_guid_t *hprotocol = handler->guid;
-			if (!hprotocol)
-				continue;
-			if (!guidcmp(hprotocol, protocol)) {
-				if (attributes !=
-				    EFI_OPEN_PROTOCOL_TEST_PROTOCOL) {
-					*protocol_interface =
-						handler->protocol_interface;
-				}
-				r = EFI_SUCCESS;
-				goto out;
-			}
-		}
-		goto unsupported;
-	}
+	r = efi_search_protocol(handle, protocol, &handler);
+	if (r != EFI_SUCCESS)
+		goto out;
 
-unsupported:
-	r = EFI_UNSUPPORTED;
+	if (attributes != EFI_OPEN_PROTOCOL_TEST_PROTOCOL)
+		*protocol_interface = handler->protocol_interface;
 out:
 	return EFI_EXIT(r);
 }
-- 
2.14.2

