From f75b2bd73d99b9b598f5616c08b43c2f265beab6 Mon Sep 17 00:00:00 2001
From: Heinrich Schuchardt <xypron.glpk@gmx.de>
Date: Tue, 26 Dec 2017 00:46:56 +0100
Subject: [PATCH v4 1/1] vsprintf.c: add EFI device path printing

For debugging efi_loader we need the capability to print EFI
device paths. With this patch we can write:

    debug("device path: %pD", dp);

A possible output would be

    device path: /MemoryMapped(0x0,0x3ff93a82,0x3ff93a82)

This enhancement is not available when building without EFI support
and neither in the SPL nor in the API example.

The test can be executed in the sandbox with command ut_print.

The development for EFI support in the sandbox is currently in
branch u-boot-dm/efi-working. The branch currently lacks
6ea8b580f06b9ba9100af1ea5fa4d160e78a4517
[PATCH v3 3/3] efi_loader: correct DeviceNodeToText for media types
Ater rebasing the aforementioned branch on U-Boot v2018.01 the
test is executed successfully.

Without EFI support in the sandbox the test is simply skipped.

Cc: Wolfgang Denk <wd@denx.de>
Cc: Simon Glass <sjg@chromium.org>
Suggested-by: Rob Clark <robdclark@gmail.com>
Signed-off-by: Heinrich Schuchardt <xypron.glpk@gmx.de>
---
I propose Alex picks up this patch for the EFI tree.

v4:
	Add unit test.
v3:
	Return -ENOMEM if out of memory.
	Avoid missing dependency error when building the SPL of the
	API example.
v2:
	Panic if out of memory.
	Wolfgang suggested not to silently ignore an out of memory
	situation.
---
 examples/api/Makefile |  3 +++
 lib/vsprintf.c        | 47 +++++++++++++++++++++++++++++++++++++++++------
 test/print_ut.c       | 37 +++++++++++++++++++++++++++++++++++++
 3 files changed, 81 insertions(+), 6 deletions(-)

diff --git a/examples/api/Makefile b/examples/api/Makefile
index 899527267d..9068727b98 100644
--- a/examples/api/Makefile
+++ b/examples/api/Makefile
@@ -4,6 +4,9 @@
 # SPDX-License-Identifier:	GPL-2.0+
 #
 
+# Provide symbol API_BUILD to signal that the API example is being built.
+KBUILD_CPPFLAGS += -DAPI_BUILD
+
 ifeq ($(ARCH),powerpc)
 LOAD_ADDR = 0x40000
 endif
diff --git a/lib/vsprintf.c b/lib/vsprintf.c
index dd572d2868..226f4eb3e5 100644
--- a/lib/vsprintf.c
+++ b/lib/vsprintf.c
@@ -11,16 +11,17 @@
  * from hush: simple_itoa() was lifted from boa-0.93.15
  */
 
-#include <stdarg.h>
-#include <linux/types.h>
-#include <linux/string.h>
-#include <linux/ctype.h>
-
 #include <common.h>
 #include <charset.h>
+#include <efi_loader.h>
+#include <div64.h>
 #include <uuid.h>
+#include <stdarg.h>
+#include <linux/ctype.h>
+#include <linux/err.h>
+#include <linux/types.h>
+#include <linux/string.h>
 
-#include <div64.h>
 #define noinline __attribute__((noinline))
 
 /* we use this so that we can do without the ctype library */
@@ -292,6 +293,26 @@ static char *string16(char *buf, char *end, u16 *s, int field_width,
 	return buf;
 }
 
+#if defined(CONFIG_EFI_LOADER) && \
+	!defined(CONFIG_SPL_BUILD) && !defined(API_BUILD)
+static char *device_path_string(char *buf, char *end, void *dp, int field_width,
+				int precision, int flags)
+{
+	u16 *str;
+
+	if (!dp)
+		return "<NULL>";
+
+	str = efi_dp_str((struct efi_device_path *)dp);
+	if (!str)
+		return ERR_PTR(-ENOMEM);
+
+	buf = string16(buf, end, str, field_width, precision, flags);
+	efi_free_pool(str);
+	return buf;
+}
+#endif
+
 #ifdef CONFIG_CMD_NET
 static const char hex_asc[] = "0123456789abcdef";
 #define hex_asc_lo(x)	hex_asc[((x) & 0x0f)]
@@ -435,6 +456,12 @@ static char *pointer(const char *fmt, char *buf, char *end, void *ptr,
 #endif
 
 	switch (*fmt) {
+#if defined(CONFIG_EFI_LOADER) && \
+	!defined(CONFIG_SPL_BUILD) && !defined(API_BUILD)
+	case 'D':
+		return device_path_string(buf, end, ptr, field_width,
+					  precision, flags);
+#endif
 #ifdef CONFIG_CMD_NET
 	case 'a':
 		flags |= SPECIAL | ZEROPAD;
@@ -604,6 +631,8 @@ repeat:
 			str = pointer(fmt + 1, str, end,
 					va_arg(args, void *),
 					field_width, precision, flags);
+			if (IS_ERR(str))
+				return PTR_ERR(str);
 			/* Skip all alphanumeric pointer suffixes */
 			while (isalnum(fmt[1]))
 				fmt++;
@@ -768,6 +797,9 @@ int printf(const char *fmt, ...)
 	i = vscnprintf(printbuffer, sizeof(printbuffer), fmt, args);
 	va_end(args);
 
+	/* Handle error */
+	if (i <= 0)
+		return i;
 	/* Print the string */
 	puts(printbuffer);
 	return i;
@@ -784,6 +816,9 @@ int vprintf(const char *fmt, va_list args)
 	 */
 	i = vscnprintf(printbuffer, sizeof(printbuffer), fmt, args);
 
+	/* Handle error */
+	if (i <= 0)
+		return i;
 	/* Print the string */
 	puts(printbuffer);
 	return i;
diff --git a/test/print_ut.c b/test/print_ut.c
index a42c554bef..d10ed8695b 100644
--- a/test/print_ut.c
+++ b/test/print_ut.c
@@ -7,12 +7,46 @@
 #define DEBUG
 
 #include <common.h>
+#if defined(CONFIG_EFI_LOADER) && \
+	!defined(CONFIG_SPL_BUILD) && !defined(API_BUILD)
+#include <efi_api.h>
+#endif
 #include <display_options.h>
 #include <version.h>
 
 #define FAKE_BUILD_TAG	"jenkins-u-boot-denx_uboot_dm-master-build-aarch64" \
 			"and a lot more text to come"
 
+/* Test efi_loader specific printing */
+static void efi_ut_print(void)
+{
+#if defined(CONFIG_EFI_LOADER) && \
+	!defined(CONFIG_SPL_BUILD) && !defined(API_BUILD)
+	char str[10];
+	u8 buf[sizeof(struct efi_device_path_sd_mmc_path) +
+	       sizeof(struct efi_device_path)];	
+	u8 *pos = buf;
+	struct efi_device_path *dp_end;
+	struct efi_device_path_sd_mmc_path *dp_sd =
+			(struct efi_device_path_sd_mmc_path *)pos;
+
+	/* Create a device path for an SD card */
+	dp_sd->dp.type = DEVICE_PATH_TYPE_MESSAGING_DEVICE;
+	dp_sd->dp.sub_type = DEVICE_PATH_SUB_TYPE_MSG_SD;
+	dp_sd->dp.length = sizeof(struct efi_device_path_sd_mmc_path);
+	dp_sd->slot_number = 3;
+	pos += sizeof(struct efi_device_path_sd_mmc_path);
+	/* Append end node */
+	dp_end = (struct efi_device_path *) pos;
+	dp_end->type = DEVICE_PATH_TYPE_END;
+	dp_end->sub_type = DEVICE_PATH_SUB_TYPE_END;
+	dp_end->length = sizeof(struct efi_device_path);
+
+	sprintf(str, "_%pD_", buf);
+	assert(!strcmp("_/SD(3)_", str));
+#endif
+}
+
 static int do_ut_print(cmd_tbl_t *cmdtp, int flag, int argc,
 		       char *const argv[])
 {
@@ -75,6 +109,9 @@ static int do_ut_print(cmd_tbl_t *cmdtp, int flag, int argc,
 	assert(!strncmp(FAKE_BUILD_TAG, s + 9 + len, 12));
 	assert(!strcmp("\n\n", s + big_str_len - 3));
 
+	/* Test efi_loader specific printing */
+	efi_ut_print();
+
 	printf("%s: Everything went swimmingly\n", __func__);
 	return 0;
 }
-- 
2.11.0

