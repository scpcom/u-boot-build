From d659de9c9aa55951ab56343685d8240fe31d459f Mon Sep 17 00:00:00 2001
From: Heinrich Schuchardt <xypron.glpk@gmx.de>
Date: Sun, 30 Jul 2017 16:51:19 +0200
Subject: [PATCH v3 3/3] efi_loader: implement OpenProtocolInformation

efi_open_protocol_information provides the agent and controller
handles as well as the attributes and open count of an protocol
on a handle.

Cc: Rob Clark <robdclark@gmail.com>
Signed-off-by: Heinrich Schuchardt <xypron.glpk@gmx.de>
---
v3:
	use list_for_each_entry
	correct indention
v2:
	new patch
---
 lib/efi_loader/efi_boottime.c | 74 ++++++++++++++++++++++++++++++++++++++++++-
 1 file changed, 73 insertions(+), 1 deletion(-)

diff --git a/lib/efi_loader/efi_boottime.c b/lib/efi_loader/efi_boottime.c
index 65a7a79dc1..fa9b74d465 100644
--- a/lib/efi_loader/efi_boottime.c
+++ b/lib/efi_loader/efi_boottime.c
@@ -984,14 +984,86 @@ out:
 	return EFI_EXIT(r);
 }
 
+static efi_status_t efi_copy_open_protocol_information(
+			struct efi_handler *protocol,
+			struct efi_open_protocol_info_entry **entry_buffer,
+			unsigned long *entry_count)
+{
+	unsigned long buffer_size;
+	unsigned long count = 0;
+	size_t i;
+	efi_status_t r;
+
+	*entry_buffer = NULL;
+
+	/* Count entries */
+	for (i = 0; i < ARRAY_SIZE(protocol->open_info); ++i) {
+		struct efi_open_protocol_info_entry *open_info =
+			&protocol->open_info[i];
+
+		if (open_info->open_count)
+			++count;
+	}
+	*entry_count = count;
+	if (!count)
+		return EFI_SUCCESS;
+
+	/* Copy entries */
+	buffer_size = count * sizeof(struct efi_open_protocol_info_entry);
+	r = efi_allocate_pool(EFI_ALLOCATE_ANY_PAGES, buffer_size,
+			      (void **)entry_buffer);
+	if (r != EFI_SUCCESS)
+		return r;
+	count = 0;
+	for (i = 0; i < ARRAY_SIZE(protocol->open_info); ++i) {
+		struct efi_open_protocol_info_entry *open_info =
+			&protocol->open_info[i];
+
+		if (!open_info->open_count)
+			continue;
+		(*entry_buffer)[count] = *open_info;
+		++count;
+	}
+
+	return EFI_SUCCESS;
+}
+
 static efi_status_t EFIAPI efi_open_protocol_information(efi_handle_t handle,
 			efi_guid_t *protocol,
 			struct efi_open_protocol_info_entry **entry_buffer,
 			unsigned long *entry_count)
 {
+	struct efi_object *efiobj;
+	size_t i;
+	efi_status_t r = EFI_NOT_FOUND;
+
 	EFI_ENTRY("%p, %p, %p, %p", handle, protocol, entry_buffer,
 		  entry_count);
-	return EFI_EXIT(EFI_NOT_FOUND);
+
+	if (!handle || !protocol || !entry_buffer)
+		EFI_EXIT(EFI_INVALID_PARAMETER);
+
+	EFI_PRINT_GUID("protocol:", protocol);
+
+	list_for_each_entry(efiobj, &efi_obj_list, link) {
+		if (efiobj->handle != handle)
+			continue;
+
+		for (i = 0; i < ARRAY_SIZE(efiobj->protocols); i++) {
+			struct efi_handler *handler = &efiobj->protocols[i];
+			const efi_guid_t *hprotocol = handler->guid;
+			if (!hprotocol)
+				continue;
+			if (!guidcmp(hprotocol, protocol)) {
+				r = efi_copy_open_protocol_information(
+					handler, entry_buffer, entry_count);
+				goto out;
+			}
+		}
+		goto out;
+	}
+out:
+	return EFI_EXIT(r);
 }
 
 static efi_status_t EFIAPI efi_protocols_per_handle(void *handle,
-- 
2.11.0

