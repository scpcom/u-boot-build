From 84520fcf53f8f366cfe449bb8a63e807083c4204 Mon Sep 17 00:00:00 2001
From: Heinrich Schuchardt <xypron.glpk@gmx.de>
Date: Sat, 2 Sep 2017 08:07:49 +0200
Subject: [PATCH 1/1] efi_selftest: provide an EFI selftest application

Provide a framework to which we can add all EFI API testing.

A standalone EFI application is provided.
This application can also be incorporated into U-Boot and be
executed with the bootefi efi_selftest command.

Signed-off-by: Heinrich Schuchardt <xypron.glpk@gmx.de>
---
 arch/arm/lib/Makefile                  |   1 +
 arch/x86/config.mk                     |   2 +-
 arch/x86/lib/Makefile                  |   2 +-
 cmd/Kconfig                            |   2 +
 cmd/bootefi.c                          |  25 ++++-
 include/asm-generic/sections.h         |   2 +
 include/efi_selftest.h                 |  54 +++++++++++
 lib/Makefile                           |   1 +
 lib/efi_selftest/Kconfig               |  19 ++++
 lib/efi_selftest/Makefile              |  26 +++++
 lib/efi_selftest/efi_conout.c          | 166 ++++++++++++++++++++++++++++++++
 lib/efi_selftest/efi_selftest.c        | 150 +++++++++++++++++++++++++++++
 lib/efi_selftest/efi_selftest_efi.d    |   1 +
 lib/efi_selftest/efi_selftest_events.c | 168 +++++++++++++++++++++++++++++++++
 14 files changed, 613 insertions(+), 6 deletions(-)
 create mode 100644 include/efi_selftest.h
 create mode 100644 lib/efi_selftest/Kconfig
 create mode 100644 lib/efi_selftest/Makefile
 create mode 100644 lib/efi_selftest/efi_conout.c
 create mode 100644 lib/efi_selftest/efi_selftest.c
 create mode 100644 lib/efi_selftest/efi_selftest_efi.d
 create mode 100644 lib/efi_selftest/efi_selftest_events.c

diff --git a/arch/arm/lib/Makefile b/arch/arm/lib/Makefile
index 6e1c436933..050789e12b 100644
--- a/arch/arm/lib/Makefile
+++ b/arch/arm/lib/Makefile
@@ -106,4 +106,5 @@ CFLAGS_$(EFI_RELOC) := $(CFLAGS_EFI)
 CFLAGS_REMOVE_$(EFI_RELOC) := $(CFLAGS_NON_EFI)
 
 extra-$(CONFIG_CMD_BOOTEFI_HELLO_COMPILE) += $(EFI_CRT0) $(EFI_RELOC)
+extra-$(CONFIG_CMD_SELFTEST_COMPILE) += $(EFI_CRT0) $(EFI_RELOC)
 extra-$(CONFIG_EFI) += $(EFI_CRT0) $(EFI_RELOC)
diff --git a/arch/x86/config.mk b/arch/x86/config.mk
index 62d00fb95f..4d7809c19c 100644
--- a/arch/x86/config.mk
+++ b/arch/x86/config.mk
@@ -91,7 +91,7 @@ else
 PLATFORM_CPPFLAGS += -D__I386__
 endif
 
-ifneq ($(CONFIG_EFI_STUB)$(CONFIG_CMD_BOOTEFI_HELLO_COMPILE),)
+ifneq ($(CONFIG_EFI_STUB)$(CONFIG_CMD_BOOTEFI_HELLO_COMPILE)$(CONFIG_CMD_SELFTEST_COMPILE),)
 
 ifeq ($(IS_32BIT),y)
 EFI_LDS := elf_ia32_efi.lds
diff --git a/arch/x86/lib/Makefile b/arch/x86/lib/Makefile
index fe00d7573f..6575e1a0cb 100644
--- a/arch/x86/lib/Makefile
+++ b/arch/x86/lib/Makefile
@@ -77,7 +77,7 @@ extra-$(CONFIG_EFI_STUB_64BIT) += crt0_x86_64_efi.o reloc_x86_64_efi.o
 
 endif
 
-ifneq ($(CONFIG_EFI_STUB)$(CONFIG_CMD_BOOTEFI_HELLO_COMPILE),)
+ifneq ($(CONFIG_EFI_STUB)$(CONFIG_CMD_BOOTEFI_HELLO_COMPILE)$(CONFIG_CMD_SELFTEST_COMPILE),)
 ifeq ($(CONFIG_$(SPL_)X86_64),)
 extra-y += $(EFI_CRT0) $(EFI_RELOC)
 endif
diff --git a/cmd/Kconfig b/cmd/Kconfig
index d6d130edfa..3ef9b16b08 100644
--- a/cmd/Kconfig
+++ b/cmd/Kconfig
@@ -222,6 +222,8 @@ config CMD_BOOTEFI_HELLO
 	  for testing that EFI is working at a basic level, and for bringing
 	  up EFI support on a new architecture.
 
+source lib/efi_selftest/Kconfig
+
 config CMD_BOOTMENU
 	bool "bootmenu"
 	select MENU
diff --git a/cmd/bootefi.c b/cmd/bootefi.c
index c5bfab1147..9dfa00032c 100644
--- a/cmd/bootefi.c
+++ b/cmd/bootefi.c
@@ -290,7 +290,8 @@ static unsigned long do_bootefi_exec(void *efi, void *fdt)
 /* Interpreter command to boot an arbitrary EFI image from memory */
 static int do_bootefi(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 {
-	char *saddr, *sfdt;
+	char *saddr = NULL;
+	char *sfdt;
 	unsigned long addr, fdt_addr = 0;
 	unsigned long r;
 
@@ -306,9 +307,21 @@ static int do_bootefi(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 		else
 			addr = CONFIG_SYS_LOAD_ADDR;
 		memcpy((char *)addr, __efi_helloworld_begin, size);
-	} else
+	}
 #endif
-	{
+#ifdef CONFIG_CMD_BOOTEFI_SELFTEST
+	if (!strcmp(argv[1], "selftest")) {
+		ulong size = __efi_efi_selftest_end - __efi_efi_selftest_begin;
+
+		saddr = env_get("loadaddr");
+		if (saddr)
+			addr = simple_strtoul(saddr, NULL, 16);
+		else
+			addr = CONFIG_SYS_LOAD_ADDR;
+		memcpy((char *)addr, __efi_efi_selftest_begin, size);
+	}
+#endif
+	if (saddr == NULL) {
 		saddr = argv[1];
 
 		addr = simple_strtoul(saddr, NULL, 16);
@@ -338,7 +351,11 @@ static char bootefi_help_text[] =
 	"    exposed as EFI configuration table.\n"
 #ifdef CONFIG_CMD_BOOTEFI_HELLO
 	"hello\n"
-	"  - boot a sample Hello World application stored within U-Boot"
+	"  - boot a sample Hello World application stored within U-Boot\n"
+#endif
+#ifdef CONFIG_CMD_BOOTEFI_SELFTEST
+	"selftest\n"
+	"  - boot an EFI efi_selftest application stored within U-Boot\n"
 #endif
 	;
 #endif
diff --git a/include/asm-generic/sections.h b/include/asm-generic/sections.h
index b6535705a5..5594082b5b 100644
--- a/include/asm-generic/sections.h
+++ b/include/asm-generic/sections.h
@@ -24,6 +24,8 @@ extern char __initdata_begin[], __initdata_end[];
 extern char __start_rodata[], __end_rodata[];
 extern char __efi_helloworld_begin[];
 extern char __efi_helloworld_end[];
+extern char __efi_efi_selftest_begin[];
+extern char __efi_efi_selftest_end[];
 
 /* Start and end of .ctors section - used for constructor calls. */
 extern char __ctors_start[], __ctors_end[];
diff --git a/include/efi_selftest.h b/include/efi_selftest.h
new file mode 100644
index 0000000000..dd5e60169f
--- /dev/null
+++ b/include/efi_selftest.h
@@ -0,0 +1,54 @@
+/*
+ *  EFI application loader
+ *
+ *  Copyright (c) 2017 Heinrich Schuchardt <xypron.glpk@gmx.de>
+ *
+ *  SPDX-License-Identifier:     GPL-2.0+
+ */
+
+#ifndef _EFI_SELFTEST_H
+#define _EFI_SELFTEST_H
+
+#include <common.h>
+#include <efi.h>
+#include <efi_api.h>
+#include <linker_lists.h>
+
+#define st_error(...) \
+	wsprintf("%s(%u):\nERROR: ", __FILE__, __LINE__); \
+	wsprintf(__VA_ARGS__) \
+
+enum efi_test_phase {
+	EFI_EXECUTE_BEFORE_BOOTTIME_EXIT = 1,
+	EFI_SETUP_BEFORE_BOOTTIME_EXIT,
+	EFI_SETUP_AFTER_BOOTTIME_EXIT,
+};
+
+extern struct efi_simple_text_output_protocol *con_out;
+
+void wsprintf(const char *fmt, ...)
+		 __attribute__ ((format (__printf__, 1, 2)));
+
+/**
+ * struct efi_unit_test - EFI unit test
+ *
+ * An efi_unit_test provides a interface to an EFI unit test.
+ *
+ * @name: Name of unit test
+ * @phase: specifies when setup and execute are executed
+ * @setup: set up the unit test
+ * @execute: execute the unit test
+ */
+struct efi_unit_test {
+	const char *name;
+	const enum efi_test_phase phase;
+	int (*setup)(const efi_handle_t handle,
+		     const struct efi_system_table *systable);
+	int (*execute)(void);
+};
+
+/* Declare a new EFI unit test */
+#define EFI_UNIT_TEST(__name)						\
+	ll_entry_declare(struct efi_unit_test, __name, efi_unit_test)
+
+#endif /* _EFI_SELFTEST_H */
diff --git a/lib/Makefile b/lib/Makefile
index 2eef1eb80e..2ffec5a455 100644
--- a/lib/Makefile
+++ b/lib/Makefile
@@ -9,6 +9,7 @@ ifndef CONFIG_SPL_BUILD
 
 obj-$(CONFIG_EFI) += efi/
 obj-$(CONFIG_EFI_LOADER) += efi_loader/
+obj-$(CONFIG_EFI_LOADER) += efi_selftest/
 obj-$(CONFIG_LZMA) += lzma/
 obj-$(CONFIG_LZO) += lzo/
 obj-$(CONFIG_ZLIB) += zlib/
diff --git a/lib/efi_selftest/Kconfig b/lib/efi_selftest/Kconfig
new file mode 100644
index 0000000000..5e67ed2422
--- /dev/null
+++ b/lib/efi_selftest/Kconfig
@@ -0,0 +1,19 @@
+config CMD_BOOTEFI_SELFTEST_COMPILE
+	bool "Compile an EFI efi_selftest application"
+	depends on CMD_BOOTEFI && (ARM || X86)
+	default y
+	help
+	  This compiles an EFI application that can be used with the test/py
+	  testing framework. It provides extended tests for of EFI
+	  API implementation.
+
+	  No additional space will be required in the resulting U-Boot binary
+	  when this option is enabled.
+
+config CMD_BOOTEFI_SELFTEST
+	bool "Allow booting an EFI efi_selftest"
+	depends on CMD_BOOTEFI_SELFTEST_COMPILE
+	help
+	  This adds an EFI test application to U-Boot that can be executed
+	  with the 'bootefi efi_selftest' command. It provides extended tests of
+	  the EFI API implementation.
diff --git a/lib/efi_selftest/Makefile b/lib/efi_selftest/Makefile
new file mode 100644
index 0000000000..ed39f52b67
--- /dev/null
+++ b/lib/efi_selftest/Makefile
@@ -0,0 +1,26 @@
+:
+# (C) Copyright 2016, Heinrich Schuchardt <xypron.glpk@gmx.de>
+#
+#  SPDX-License-Identifier:     GPL-2.0+
+#
+
+# This file only gets included with CONFIG_EFI_LOADER set, so all
+# object inclusion implicitly depends on it
+
+CFLAGS_efi_conout.o := $(CFLAGS_EFI)
+CFLAGS_REMOVE_efi_conout.o := $(CFLAGS_NON_EFI)
+CFLAGS_efi_selftest.o := $(CFLAGS_EFI)
+CFLAGS_REMOVE_efi_selftest.o := $(CFLAGS_NON_EFI)
+CFLAGS_efi_selftest_events.o := $(CFLAGS_EFI)
+CFLAGS_REMOVE_efi_selftest_events.o := $(CFLAGS_NON_EFI)
+
+efi_selftest-objs = \
+efi_conout.o \
+efi_selftest.o \
+efi_selftest_events.o
+
+ifneq ($(CONFIG_CMD_BOOTEFI_SELFTEST_COMPILE),)
+always += efi_selftest.efi
+endif
+
+obj-$(CONFIG_CMD_BOOTEFI_SELFTEST) += efi_selftest_efi.o
diff --git a/lib/efi_selftest/efi_conout.c b/lib/efi_selftest/efi_conout.c
new file mode 100644
index 0000000000..a87b9936bf
--- /dev/null
+++ b/lib/efi_selftest/efi_conout.c
@@ -0,0 +1,166 @@
+/*
+ * EFI efi_selftest
+ *
+ * Copyright (c) 2017 Heinrich Schuchardt <xypron.glpk@gmx.de>
+ *
+ * SPDX-License-Identifier:     GPL-2.0+
+ */
+
+#include <efi_selftest.h>
+#include <vsprintf.h>
+
+struct efi_simple_text_output_protocol *con_out;
+
+/*
+ * Print a pointer to an u16 string
+ *
+ * @pointer: pointer
+ * @buf: pointer to buffer address
+ * on return position of terminating zero word
+ */
+static void pointer(void *pointer, u16 **buf)
+{
+	int i;
+	u16 c;
+	uintptr_t p = (uintptr_t) pointer;
+	u16 *pos = *buf;
+
+	for (i = 8 * sizeof(p) - 4; i >= 0; i -= 4) {
+		c = (p >> i) & 0x0f;
+		c += '0';
+		if (c > '9')
+			c += 'a' - '9' - 1;
+		*pos++ = c;
+	}
+	*pos = 0;
+	*buf = pos;
+}
+
+/*
+ * Print an unsigned 32bit value as decimal number to an u16 string
+ *
+ * @value: value to be printed
+ * @buf: pointer to buffer address
+ * on return position of terminating zero word
+ */
+static void uint2dec(u32 value, u16 **buf)
+{
+	u16 *pos = *buf;
+	int i;
+	u16 c;
+	/*
+	 * Increment by .5 and multiply with
+	 * (2 << 60) / 1,000,000,000 = 0x44B82FA0.9B5A52CC
+	 * to move the first digit to bit 60-63.
+	 */
+	u64 f = 0x225C17D0;
+	f += (0x9B5A52DULL * value) >> 28;
+	f += 0x44B82FA0ULL * value;
+
+	for (i = 0; i < 10; ++i) {
+		/* Write current digit */
+		c = f >> 60;
+		if (c || pos != *buf)
+			*pos++ = c + '0';
+		/* Eliminate current digit */
+		f &= 0xfffffffffffffff;
+		/* Get next digit */
+		f *= 0xaULL;
+	}
+	if (pos == *buf)
+		*pos++ = '0';
+	*pos = 0;
+	*buf = pos;
+}
+
+/*
+ * Print a signed 32bit value as decimal number to an u16 string
+ *
+ * @value: value to be printed
+ * @buf: pointer to buffer address
+ * on return position of terminating zero word
+ */
+static void int2dec(s32 value, u16 **buf)
+{
+	u32 u;
+	u16 *pos = *buf;
+
+	if (value < 0) {
+		*pos++ = '-';
+		u = -value;
+	} else {
+		u = value;
+	}
+	uint2dec(u, &pos);
+	*buf = pos;
+}
+/*
+ * Print a formatted string to the EFI console
+ *
+ * @fmt: format string
+ * @...: optional arguments
+ */
+void wsprintf(const char *fmt, ...)
+{
+	va_list args;
+	u16 buf[160];
+	const char *c;
+	u16 *pos = buf;
+	const char *s;
+
+	va_start(args, fmt);
+
+	c = fmt;
+	for (; *c; ++c) {
+		switch (*c) {
+		case '\\':
+			++c;
+			switch (*c) {
+			case '\0':
+				--c;
+				break;
+			case 'n':
+				*pos++ = '\n';
+				break;
+			case 'r':
+				*pos++ = '\r';
+				break;
+			case 't':
+				*pos++ = '\t';
+				break;
+			default:
+				*pos++ = *c;
+			}
+			break;
+		case '%':
+			++c;
+			switch (*c) {
+			case '\0':
+				--c;
+				break;
+			case 'd':
+				int2dec(va_arg(args, s32), &pos);
+				break;
+			case 'p':
+				pointer(va_arg(args, void*), &pos);
+				break;
+			case 's':
+				s = va_arg(args, const char *);
+				for (; *s; ++s)
+					*pos++ = *s;
+				break;
+			case 'u':
+				uint2dec(va_arg(args, u32), &pos);
+				break;
+			default:
+				break;
+			}
+			break;
+		default:
+			*pos++ = *c;
+		}
+	}
+	va_end(args);
+	*pos = 0;
+	con_out->output_string(con_out, buf);
+}
diff --git a/lib/efi_selftest/efi_selftest.c b/lib/efi_selftest/efi_selftest.c
new file mode 100644
index 0000000000..15d3906a6b
--- /dev/null
+++ b/lib/efi_selftest/efi_selftest.c
@@ -0,0 +1,150 @@
+/*
+ * EFI efi_selftest
+ *
+ * Copyright (c) 2017 Heinrich Schuchardt <xypron.glpk@gmx.de>
+ *
+ * SPDX-License-Identifier:     GPL-2.0+
+ */
+
+#include <efi_selftest.h>
+#include <vsprintf.h>
+
+static const struct efi_system_table *systable;
+static const struct efi_boot_services *boottime;
+static const struct efi_runtime_services *runtime;
+static efi_handle_t handle;
+static u16 reset_message[] = L"Selftest completed";
+
+static void exit_boot_services(void)
+{
+	unsigned long  map_size = 0;
+	unsigned long  map_key;
+	unsigned long desc_size;
+	uint32_t desc_version;
+	efi_status_t ret;
+	struct efi_mem_desc *memory_map;
+
+	ret = boottime->get_memory_map(&map_size, NULL, &map_key, &desc_size, &desc_version);
+	if (ret != EFI_BUFFER_TOO_SMALL) {
+		wsprintf("ERROR: GetMemoryMap did not return EFI_BUFFER_TOO_SMALL\n");
+		return;
+	}
+	/* Allocate extra space for newly allocated memory */
+	map_size += sizeof(struct efi_mem_desc);
+	ret = boottime->allocate_pool(EFI_BOOT_SERVICES_DATA, map_size, (void**)&memory_map);
+	if (ret != EFI_SUCCESS) {
+		wsprintf("ERROR: AllocatePool did not return EFI_SUCCESS\n");
+		return;
+	}
+	ret = boottime->get_memory_map(&map_size, memory_map, &map_key, &desc_size, &desc_version);
+	if (ret != EFI_SUCCESS) {
+		wsprintf("ERROR: GetMemoryMap did not return EFI_SUCCESS\n");
+		return;
+	}
+	wsprintf("Map key = %u\n", (unsigned) map_key);
+	ret = boottime->exit_boot_services(handle, map_key);
+	if (ret != EFI_SUCCESS) {
+		wsprintf("ERROR: ExitBootServices did not return EFI_SUCCESS\n");
+		return;
+	}
+	wsprintf("Boot services terminated\n");
+}
+
+static int setup(struct efi_unit_test *test, unsigned *failures)
+{
+	int ret;
+
+	wsprintf("\nSetting up '%s'\n", test->name);
+	ret = test->setup(handle, systable);
+	if (ret) {
+		wsprintf("ERROR: Setting up '%s' failed\n", test->name);
+		++*failures;
+	} else {
+		wsprintf("Setting up '%s' succeeded\n", test->name);
+	}
+	return ret;
+}
+
+static int execute(struct efi_unit_test *test, unsigned *failures)
+{
+	int ret;
+
+	wsprintf("\nExecuting '%s'\n", test->name);
+	ret = test->execute();
+	if (ret) {
+		wsprintf("ERROR: Executing '%s' failed\n", test->name);
+		++*failures;
+	} else {
+		wsprintf("Executing '%s' succeeded\n", test->name);
+	}
+	return ret;
+}
+
+efi_status_t EFIAPI efi_main(efi_handle_t image_handle,
+                             struct efi_system_table *systab)
+{
+	struct efi_unit_test *test;
+	struct efi_simple_input_interface *con_in;
+	struct efi_input_key input_key;
+	unsigned failures = 0;
+	int ret;
+
+	systable = systab;
+	boottime = systable->boottime;
+	runtime = systable->runtime;
+	handle = image_handle;
+	con_out = systable->con_out;
+	con_in = systable->con_in;
+
+	wsprintf("Starting efi_selftest\n");
+
+	wsprintf("Number of tests: %u\n",
+		 ll_entry_count(struct efi_unit_test, efi_unit_test));
+
+	for (test = ll_entry_start(struct efi_unit_test, efi_unit_test);
+	     test < ll_entry_end(struct efi_unit_test, efi_unit_test); ++test) {
+		if (test->phase == EFI_EXECUTE_BEFORE_BOOTTIME_EXIT) {
+			setup(test, &failures);
+			execute(test, &failures);
+		}
+	}
+
+	for (test = ll_entry_start(struct efi_unit_test, efi_unit_test);
+	     test < ll_entry_end(struct efi_unit_test, efi_unit_test); ++test) {
+		if (test->phase == EFI_SETUP_BEFORE_BOOTTIME_EXIT)
+			setup(test, &failures);
+	}
+
+	exit_boot_services();
+
+	for (test = ll_entry_start(struct efi_unit_test, efi_unit_test);
+	     test < ll_entry_end(struct efi_unit_test, efi_unit_test); ++test) {
+		if (test->phase == EFI_SETUP_BEFORE_BOOTTIME_EXIT)
+			execute(test, &failures);
+	}
+
+	for (test = ll_entry_start(struct efi_unit_test, efi_unit_test);
+	     test < ll_entry_end(struct efi_unit_test, efi_unit_test); ++test) {
+		if (test->phase == EFI_SETUP_AFTER_BOOTTIME_EXIT) {
+			setup(test, &failures);
+			execute(test, &failures);
+		}
+	}
+
+	wsprintf("\nSummary: %u failures\n\n", failures);
+	wsprintf("Preparing for reset.\n");
+	/* Empty key buffer */
+	do {
+		ret = con_in->read_key_stroke(con_in, &input_key);
+	} while (ret == EFI_SUCCESS);
+	wsprintf("Press any key.\n");
+	/* Wait for next key */
+	do {
+		ret = con_in->read_key_stroke(con_in, &input_key);
+	} while (ret == EFI_NOT_READY);
+	runtime->reset_system(EFI_RESET_WARM, EFI_NOT_READY,
+			      sizeof(reset_message), reset_message);
+	wsprintf("\nERROR: reset failed.\n");
+
+	return EFI_UNSUPPORTED;
+}
diff --git a/lib/efi_selftest/efi_selftest_efi.d b/lib/efi_selftest/efi_selftest_efi.d
new file mode 100644
index 0000000000..f53b94b86d
--- /dev/null
+++ b/lib/efi_selftest/efi_selftest_efi.d
@@ -0,0 +1 @@
+lib/efi_selftest/efi_selftest_efi.dep: lib/efi_selftest/efi_conout.o lib/efi_selftest/efi_selftest.o lib/efi_selftest/efi_selftest_events.o
diff --git a/lib/efi_selftest/efi_selftest_events.c b/lib/efi_selftest/efi_selftest_events.c
new file mode 100644
index 0000000000..b3122a1b3e
--- /dev/null
+++ b/lib/efi_selftest/efi_selftest_events.c
@@ -0,0 +1,168 @@
+
+#include <efi_selftest.h>
+
+static struct efi_event *event_notify;
+static struct efi_event *event_wait;
+static unsigned int counter;
+static struct efi_boot_services *boottime;
+
+void EFIAPI notify(struct efi_event *event, void *context)
+{
+	if (!context)
+		return;
+	++*(unsigned int *)context;
+}
+static int setup(const efi_handle_t handle,
+		 const struct efi_system_table *systable)
+{
+	efi_status_t ret;
+
+	boottime = systable->boottime;
+
+	ret = boottime->create_event(EVT_TIMER | EVT_NOTIFY_SIGNAL,
+				     TPL_CALLBACK, notify, (void *)&counter,
+				     &event_notify);
+	if (ret != EFI_SUCCESS) {
+		st_error("could not create event\n");
+		return 1;
+	}
+	ret = boottime->create_event(EVT_TIMER | EVT_NOTIFY_WAIT,
+				     TPL_CALLBACK, notify, (void *)&counter,
+				     &event_wait);
+	if (ret != EFI_SUCCESS) {
+		st_error("could not create event\n");
+		return 1;
+	}
+	return 0;
+}
+
+int teardown(void)
+{
+	efi_status_t ret;
+
+	if (event_notify) {
+		ret = boottime->close_event(event_notify);
+		event_notify = NULL;
+		if (ret != EFI_SUCCESS) {
+			st_error("could not close event\n");
+			return 1;
+		}
+	}
+	if (event_wait) {
+		ret = boottime->close_event(event_wait);
+		event_wait = NULL;
+		if (ret != EFI_SUCCESS) {
+			st_error("could not close event\n");
+			return 1;
+		}
+	}
+	return 0;
+}
+
+int execute(void)
+{
+	unsigned long index;
+	efi_status_t ret;
+
+	/* Set 10 ms timer */
+	counter = 0;
+	ret = boottime->set_timer(event_notify, EFI_TIMER_PERIODIC, 100000);
+	if (ret != EFI_SUCCESS) {
+		st_error("Could not set timer\n");
+		teardown();
+		return 1;
+	}
+	/* Set 100 ms timer */
+	ret = boottime->set_timer(event_wait, EFI_TIMER_RELATIVE, 1000000);
+	if (ret != EFI_SUCCESS) {
+		st_error("Could not set timer\n");
+		teardown();
+		return 1;
+	}
+
+	index = 5;
+	ret = boottime->wait_for_event(1, &event_wait, &index);
+	if (ret != EFI_SUCCESS) {
+		st_error("Could not wait for event\n");
+		teardown();
+		return 1;
+	}
+	ret = boottime->check_event(event_wait);
+	if (ret != EFI_NOT_READY) {
+		st_error("Signaled state was not cleared.\n");
+		wsprintf("ret = %u\n", (unsigned int) ret);
+		teardown();
+		return 1;
+	}
+	if (index != 0) {
+		st_error("WaitForEvent returned wrong index\n");
+		teardown();
+		return 1;
+	}
+	wsprintf("Counter periodic: %u\n", counter);
+	if (counter < 8 || counter > 12) {
+		st_error("Incorrect timing of events\n");
+		teardown();
+		return 1;
+	}
+	ret = boottime->set_timer(event_notify, EFI_TIMER_STOP, 0);
+	if (index != 0) {
+		st_error("Could not cancel timer\n");
+		teardown();
+		return 1;
+	}
+	/* Set 10 ms timer */
+	counter = 0;
+	ret = boottime->set_timer(event_notify, EFI_TIMER_RELATIVE, 100000);
+	if (index != 0) {
+		st_error("Could not set timer\n");
+		teardown();
+		return 1;
+	}
+	/* Set 100 ms timer */
+	ret = boottime->set_timer(event_wait, EFI_TIMER_PERIODIC, 1000000);
+	if (index != 0) {
+		st_error("Could not set timer\n");
+		teardown();
+		return 1;
+	}
+	ret = boottime->wait_for_event(1, &event_wait, &index);
+	if (ret != EFI_SUCCESS) {
+		st_error("Could not wait for event\n");
+		teardown();
+		return 1;
+	}
+	wsprintf("Counter single shot: %u\n", counter);
+	if (counter != 1) {
+		st_error("Single shot timer failed\n");
+		teardown();
+		return 1;
+	}
+	ret = boottime->wait_for_event(1, &event_wait, &index);
+	if (ret != EFI_SUCCESS) {
+		st_error("Could not wait for event\n");
+		teardown();
+		return 1;
+	}
+	wsprintf("Stopped counter: %u\n", counter);
+	if (counter != 1) {
+		st_error("Stopped timer fired\n");
+		teardown();
+		return 1;
+	}
+	ret = boottime->set_timer(event_wait, EFI_TIMER_STOP, 0);
+	if (index != 0) {
+		st_error("Could not cancel timer\n");
+		teardown();
+		return 1;
+	}
+
+	return teardown();
+}
+
+EFI_UNIT_TEST(events) = {
+	.name = "event services",
+	.phase = EFI_EXECUTE_BEFORE_BOOTTIME_EXIT,
+	.setup = setup,
+	.execute = execute,
+};
-- 
2.11.0

