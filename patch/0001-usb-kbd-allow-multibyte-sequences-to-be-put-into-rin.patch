From 6e6d7b3fd6d1d1e55c66039f8e28eb34302c2ce3 Mon Sep 17 00:00:00 2001
From: Heinrich Schuchardt <xypron.glpk@gmx.de>
Date: Wed, 21 Feb 2018 18:17:55 +0100
Subject: [PATCH 1/1] usb: kbd: allow multibyte sequences to be put into ring
 buffer

The USB keyboard driver provides a ring buffer for key strokes.

Function keys cannot be encoded as single bytes. Instead xterm control
sequences have to be put into the ring buffer.

This preparatory patch changes function usb_kbd_put_queue() to allow adding
multiple characters at once. If the buffer cannot accommodate the whole
sequence, it is rejected completely.

Signed-off-by: Heinrich Schuchardt <xypron.glpk@gmx.de>
---
 common/usb_kbd.c | 42 +++++++++++++++++++++++++-----------------
 1 file changed, 25 insertions(+), 17 deletions(-)

diff --git a/common/usb_kbd.c b/common/usb_kbd.c
index 8cbdba6ac29..f914b1b87a8 100644
--- a/common/usb_kbd.c
+++ b/common/usb_kbd.c
@@ -125,24 +125,32 @@ extern int __maybe_unused net_busy_flag;
 /* The period of time between two calls of usb_kbd_testc(). */
 static unsigned long __maybe_unused kbd_testc_tms;
 
-/* Puts character in the queue and sets up the in and out pointer. */
-static void usb_kbd_put_queue(struct usb_kbd_pdata *data, char c)
+/*
+ * Put characters into ring buffer.
+ *
+ * @data:	private data
+ * @buf		buffer with data to be queued
+ * @count:	number of characters to be queued
+ */
+static void usb_kbd_put_queue(struct usb_kbd_pdata *data,
+			      uint8_t *buf, int count)
 {
-	if (data->usb_in_pointer == USB_KBD_BUFFER_LEN - 1) {
-		/* Check for buffer full. */
-		if (data->usb_out_pointer == 0)
-			return;
-
-		data->usb_in_pointer = 0;
-	} else {
-		/* Check for buffer full. */
-		if (data->usb_in_pointer == data->usb_out_pointer - 1)
-			return;
-
-		data->usb_in_pointer++;
+	int i, used;
+
+	/* Check if buffer holds at least 'count' free slots */
+	used = data->usb_in_pointer - data->usb_out_pointer;
+	if (used < 0)
+		used += USB_KBD_BUFFER_LEN;
+	if (used + count >= USB_KBD_BUFFER_LEN)
+		return;
+
+	/* Copy to buffer */
+	for (i = 0; i < count; ++i) {
+		++data->usb_in_pointer;
+		if (data->usb_in_pointer == USB_KBD_BUFFER_LEN)
+			data->usb_in_pointer = 0;
+		data->usb_kbd_buffer[data->usb_in_pointer] = c[i];
 	}
-
-	data->usb_kbd_buffer[data->usb_in_pointer] = c;
 }
 
 /*
@@ -237,7 +245,7 @@ static int usb_kbd_translate(struct usb_kbd_pdata *data, unsigned char scancode,
 	/* Report keycode if any */
 	if (keycode) {
 		debug("%c", keycode);
-		usb_kbd_put_queue(data, keycode);
+		usb_kbd_put_queue(data, &keycode, 1);
 	}
 
 	return 0;
-- 
2.15.1

