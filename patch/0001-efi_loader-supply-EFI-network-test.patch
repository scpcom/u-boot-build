From d3a662b8e842357ae394fd550ad0f050d16a8273 Mon Sep 17 00:00:00 2001
From: Heinrich Schuchardt <xypron.glpk@gmx.de>
Date: Fri, 22 Sep 2017 12:57:08 +0200
Subject: [PATCH 1/1] efi_loader: supply EFI network test

This patch provices an EFI application to check the correct function
of the Simple Network Protocol implementation.

It sends a DHCP request and analyzes the DHCP offer.

Signed-off-by: Heinrich Schuchardt <xypron.glpk@gmx.de>
---
 cmd/Kconfig                       |  20 +++
 cmd/bootefi.c                     |  17 +++
 include/asm-generic/sections.h    |   2 +
 lib/efi_loader/Makefile           |   7 +
 lib/efi_loader/efi_network_test.c | 271 ++++++++++++++++++++++++++++++++++++++
 5 files changed, 317 insertions(+)
 create mode 100644 lib/efi_loader/efi_network_test.c

diff --git a/cmd/Kconfig b/cmd/Kconfig
index 3ef9b16b08..e0a925700f 100644
--- a/cmd/Kconfig
+++ b/cmd/Kconfig
@@ -222,6 +222,26 @@ config CMD_BOOTEFI_HELLO
 	  for testing that EFI is working at a basic level, and for bringing
 	  up EFI support on a new architecture.
 
+config CMD_BOOTEFI_NETWORK_TEST_COMPILE
+	bool "Compile an EFI application for network testing"
+	depends on CMD_BOOTEFI && (ARM || X86)
+	default y
+	help
+	  This compiles an EFI application that tests the implemenation of the
+	  Simple Network Protocol (SNP) by sending a DHCP request and reading
+	  the DHCP offer.
+
+	  No additional space will be required in the resulting U-Boot binary
+	  when this option is enabled.
+
+config CMD_BOOTEFI_NETWORK_TEST
+	bool "Allow booting an EFI application for network testing"
+	depends on CMD_BOOTEFI_NETWORK_TEST_COMPILE
+	help
+	  This adds an EFI application that tests the implemenation of the
+	  Simple Network Protocol (SNP) so that it can be used with the
+	  'bootefi nettest' command.
+
 source lib/efi_selftest/Kconfig
 
 config CMD_BOOTMENU
diff --git a/cmd/bootefi.c b/cmd/bootefi.c
index b7087e3da8..05e072e768 100644
--- a/cmd/bootefi.c
+++ b/cmd/bootefi.c
@@ -270,6 +270,19 @@ static int do_bootefi(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 		memcpy((char *)addr, __efi_helloworld_begin, size);
 	} else
 #endif
+#ifdef CONFIG_CMD_BOOTEFI_NETWORK_TEST
+	if (!strcmp(argv[1], "nettest")) {
+		ulong size = __efi_efi_network_test_end -
+			     __efi_efi_network_test_begin;
+
+		saddr = env_get("loadaddr");
+		if (saddr)
+			addr = simple_strtoul(saddr, NULL, 16);
+		else
+			addr = CONFIG_SYS_LOAD_ADDR;
+		memcpy((char *)addr, __efi_efi_network_test_begin, size);
+	} else
+#endif
 #ifdef CONFIG_CMD_BOOTEFI_SELFTEST
 	if (!strcmp(argv[1], "selftest")) {
 		struct efi_loaded_image loaded_image_info = {};
@@ -330,6 +343,10 @@ static char bootefi_help_text[] =
 	"bootefi hello\n"
 	"  - boot a sample Hello World application stored within U-Boot\n"
 #endif
+#ifdef CONFIG_CMD_BOOTEFI_NETWORK_TEST
+	"bootefi nettest\n"
+	"  - boot an EFI network test application stored within U-Boot\n"
+#endif
 #ifdef CONFIG_CMD_BOOTEFI_SELFTEST
 	"bootefi selftest\n"
 	"  - boot an EFI selftest application stored within U-Boot\n"
diff --git a/include/asm-generic/sections.h b/include/asm-generic/sections.h
index b6535705a5..1ee56c52f5 100644
--- a/include/asm-generic/sections.h
+++ b/include/asm-generic/sections.h
@@ -24,6 +24,8 @@ extern char __initdata_begin[], __initdata_end[];
 extern char __start_rodata[], __end_rodata[];
 extern char __efi_helloworld_begin[];
 extern char __efi_helloworld_end[];
+extern char __efi_efi_network_test_begin[];
+extern char __efi_efi_network_test_end[];
 
 /* Start and end of .ctors section - used for constructor calls. */
 extern char __ctors_start[], __ctors_end[];
diff --git a/lib/efi_loader/Makefile b/lib/efi_loader/Makefile
index ddb978f650..00ebf1cb8d 100644
--- a/lib/efi_loader/Makefile
+++ b/lib/efi_loader/Makefile
@@ -9,12 +9,19 @@
 
 CFLAGS_helloworld.o := $(CFLAGS_EFI)
 CFLAGS_REMOVE_helloworld.o := $(CFLAGS_NON_EFI)
+CFLAGS_efi_network_test.o := $(CFLAGS_EFI)
+CFLAGS_efi_network_test.o := $(CFLAGS_NON_EFI)
 
 ifneq ($(CONFIG_CMD_BOOTEFI_HELLO_COMPILE),)
 always += helloworld.efi
 endif
 
+ifneq ($(CONFIG_CMD_BOOTEFI_NETWORK_TEST_COMPILE),)
+always += efi_network_test.efi
+endif
+
 obj-$(CONFIG_CMD_BOOTEFI_HELLO) += helloworld_efi.o
+obj-$(CONFIG_CMD_BOOTEFI_NETWORK_TEST) += efi_network_test_efi.o
 obj-y += efi_image_loader.o efi_boottime.o efi_runtime.o efi_console.o
 obj-y += efi_memory.o efi_device_path_to_text.o efi_device_path.o
 obj-y += efi_file.o efi_variable.o efi_bootmgr.o
diff --git a/lib/efi_loader/efi_network_test.c b/lib/efi_loader/efi_network_test.c
new file mode 100644
index 0000000000..cd2e28f156
--- /dev/null
+++ b/lib/efi_loader/efi_network_test.c
@@ -0,0 +1,271 @@
+/*
+ * EFI hello world
+ *
+ * Copyright (c) 2017 Heinrich Schuchardt <xypron.glpk@gmx.de>
+ * Written by Simon Glass <sjg@chromium.org>
+ *
+ * SPDX-License-Identifier:     GPL-2.0+
+ */
+
+#include <efi_selftest.h>
+
+struct dhcp_hdr {
+	u8 op;
+#define BOOTREQUEST 1
+#define BOOTREPLY 2
+	u8 htype;
+# define HWT_ETHER 1
+	u8 hlen;
+# define HWL_ETHER 6
+	u8 hops;
+	u32 xid;
+	u16 secs;
+	u16 flags;
+	u32 ciaddr;
+	u32 yiaddr;
+	u32 siaddr;
+	u32 giaddr;
+	u8 chaddr[16];
+	u8 sname[64];
+	u8 file[128];
+};
+
+#define DHCP_MESSAGE_TYPE 0x35
+#define DHCPDISCOVER	1
+#define DHCPOFFER	2
+#define DHCPREQUEST	3
+#define DHCPDECLINE	4
+#define DHCPACK		5
+#define DHCPNAK		6
+#define DHCPRELEASE	7
+
+struct dhcp {
+	struct ethernet_hdr eth_hdr;
+	struct ip_udp_hdr ip_udp;
+	struct dhcp_hdr dhcp_hdr;
+	u8 opt[128];
+} __packed;
+
+static struct efi_boot_services *boottime;
+static struct efi_simple_network *net = NULL;
+static struct efi_event *timer = NULL;
+static const efi_guid_t efi_net_guid = EFI_SIMPLE_NETWORK_GUID;
+/* IP packet ID */
+static unsigned net_ip_id;
+
+#include "../../lib/efi_selftest/efi_selftest_console.c"
+
+void *memset(void *s, int c, size_t n)
+{
+	char *pos = s;
+
+	for (; n; --n) {
+		*pos++ = c;
+	}
+	return s;
+}
+
+void *memcpy(void *d, const void *s, size_t n) {
+	const char *poss = s;
+	char *posd = d;
+
+	for (; n; --n) {
+		*posd++ = *poss++;
+	}
+	return d;
+}
+
+efi_status_t send_dhcp_request(void)
+{
+	struct dhcp p = {};
+
+	/*
+	 * Fill ethernet header
+	 */
+	memset(p.eth_hdr.et_dest, 0xff, ARP_HLEN);
+	memcpy(p.eth_hdr.et_src, &net->mode->current_address, ARP_HLEN);
+	p.eth_hdr.et_protlen = htons(PROT_IP);
+	/*
+	 * Fill IP header
+	 */
+	p.ip_udp.ip_hl_v	= 0x45;
+	p.ip_udp.ip_tos		= 0;
+	p.ip_udp.ip_len		= htons(sizeof(struct dhcp) -
+	                                sizeof(struct ethernet_hdr));
+	p.ip_udp.ip_id		= htons(++net_ip_id);
+	p.ip_udp.ip_off		= htons(IP_FLAGS_DFRAG);
+	p.ip_udp.ip_ttl		= 0xff; /* time to live */
+	p.ip_udp.ip_p		= IPPROTO_UDP;
+	p.ip_udp.ip_sum		= 0;
+	/*
+	 * Fill UDP header
+	 */
+	memset(&p.ip_udp.ip_dst, 0xff, 4);
+	p.ip_udp.udp_src	= htons(68);
+	p.ip_udp.udp_dst	= htons(67);
+	p.ip_udp.udp_len	= htons(sizeof(struct dhcp) -
+	                                sizeof(struct ethernet_hdr) -
+	                                sizeof(struct ip_hdr));
+	/*
+	 * Fill DHCP header
+	 */
+	p.dhcp_hdr.op = BOOTREQUEST;
+	p.dhcp_hdr.htype = HWT_ETHER;
+	p.dhcp_hdr.hlen = HWL_ETHER;
+	p.dhcp_hdr.flags = htons(0x0080);
+	memcpy(&p.dhcp_hdr.chaddr, &net->mode->current_address, ARP_HLEN);
+	/*
+	 * Fill options
+	 */
+	p.opt[0] = 0x63; /* Magic cookie */
+	p.opt[1] = 0x82;
+	p.opt[2] = 0x53;
+	p.opt[3] = 0x63;
+	p.opt[4] = DHCP_MESSAGE_TYPE;
+	p.opt[5] = 0x01; /* length */
+	p.opt[6] = DHCPDISCOVER;
+	p.opt[7] = 0xff;
+
+	return net->transmit(net, 0, sizeof(struct dhcp), &p, NULL, NULL, 0);
+}
+
+efi_status_t EFIAPI efi_main(efi_handle_t handle,
+                             struct efi_system_table *systable)
+{
+	efi_status_t exit_status, ret;
+	struct efi_event *events[2];
+	unsigned int timeout = 10;
+	size_t index;
+
+	boottime = systable->boottime;
+	con_out = systable->con_out;
+	con_in = systable->con_in;
+
+	efi_st_printf("Network test\n");
+
+	exit_status = EFI_SUCCESS;
+	/*
+	 * Create a timer event.
+	 */
+	ret = boottime->create_event(EVT_TIMER, TPL_CALLBACK, NULL, NULL,
+	                             &timer);
+	if (ret != EFI_SUCCESS) {
+		efi_st_error("Failed to create event\n");
+		goto out;
+	}
+	/*
+	 * Set timer period to 1s.
+	 */
+	ret = boottime->set_timer(timer, EFI_TIMER_PERIODIC, 10000000);
+	if (ret != EFI_SUCCESS) {
+		efi_st_error("Failed to locate simple network protocol\n");
+		goto out;
+	}
+	/*
+	 * Find an interface implementing the SNP protocol.
+	 */
+	ret = boottime->locate_protocol(&efi_net_guid, NULL, (void **) &net);
+	if (ret != EFI_SUCCESS) {
+		efi_st_error("Failed to locate simple network protocol\n");
+		goto out;
+	}
+	/*
+	 * Check hardware address size.
+	 */
+	if (!net->mode) {
+		efi_st_error("Mode not provided\n");
+		goto out;
+	}
+	if (net->mode->hwaddr_size != ARP_HLEN + 1) {
+		efi_st_error("HwAddressSize = %u, expected %u\n",
+			     net->mode->hwaddr_size, ARP_HLEN);
+		goto out;
+	}
+	if (!net->wait_for_packet) {
+		efi_st_error("WaitForPacket event missing\n");
+		goto out;
+	}
+	/*
+	 * Initialize network adapter.
+	 */
+	ret = net->initialize(net, 0, 0);
+	if (ret != EFI_SUCCESS) {
+		efi_st_error("Failed to initialize network adapter\n");
+		goto out;
+	}
+	/*
+	 * Start network adapter.
+	 */
+	ret = net->start(net);
+	if (ret != EFI_SUCCESS) {
+		efi_st_error("Failed to start network adapter\n");
+		goto out;
+	}
+
+	ret = send_dhcp_request();
+	if (ret != EFI_SUCCESS) {
+		efi_st_error("Sending an DHCP request failed\n");
+		goto out;
+	}
+
+
+	events[0] = timer;
+	events[1] = net->wait_for_packet;
+	for (;;) {
+		boottime->wait_for_event(2, events, &index);
+		if (index == 0) {
+			--timeout;
+			if (!timeout) {
+				efi_st_error("Timeout occurred\n");
+				goto out;
+			}
+			continue;
+		}
+	}
+
+	/*
+	 * Stop network adapter.
+	 */
+	ret = net->stop(net);
+	if (ret != EFI_SUCCESS) {
+		efi_st_error("Failed to stop network adapter\n");
+		goto out;
+	}
+out:
+	exit_status = ret;
+	if (timer) {
+		/*
+		 * Stop timer.
+		 */
+		ret = boottime->set_timer(timer, EFI_TIMER_STOP, 0);
+		if (ret != EFI_SUCCESS) {
+			efi_st_error("Failed to stop timer");
+			exit_status = ret;
+		}
+		/*
+		 * Close timer event.
+		 */
+		ret = boottime->close_event(timer);
+		if (ret != EFI_SUCCESS) {
+			efi_st_error("Failed to close event");
+			exit_status = ret;
+		}
+	}
+	if (net) {
+		/*
+		 * Shut down network adapter.
+		 */
+		ret = net->shutdown(net);
+		if (ret != EFI_SUCCESS) {
+			efi_st_error("Failed to shut down network adapter\n");
+			exit_status = ret;
+		}
+	}
+
+	if (exit_status == EFI_SUCCESS)
+		efi_st_printf("The test ran successfully\n");
+
+	boottime->exit(handle, exit_status, 0, NULL);
+
+	return EFI_SUCCESS;
+}
-- 
2.11.0

