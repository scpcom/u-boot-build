From a4b7815bee821389ccd34cfb6024042349e4ef97 Mon Sep 17 00:00:00 2001
From: Heinrich Schuchardt <xypron.glpk@gmx.de>
Date: Sun, 2 Jul 2017 14:48:05 +0200
Subject: [PATCH v2 4/4] efi_loader: correctly implement 100ns conversion

In efi_set_timer we receive the trigger time in intervals of 100 ns.
We should convert it to intervals of 1000 ns by 64bit division.

The patch supplies function efi_div10 that uses multiplication to
implement the missing 64 bit division.

Signed-off-by: Heinrich Schuchardt <xypron.glpk@gmx.de>
---
 lib/efi_loader/efi_boottime.c | 56 +++++++++++++++++++++++++++++++++----------
 1 file changed, 43 insertions(+), 13 deletions(-)

diff --git a/lib/efi_loader/efi_boottime.c b/lib/efi_loader/efi_boottime.c
index 884587dcae..d5da6b2fb2 100644
--- a/lib/efi_loader/efi_boottime.c
+++ b/lib/efi_loader/efi_boottime.c
@@ -82,6 +82,38 @@ efi_status_t efi_exit_func(efi_status_t ret)
 	return ret;
 }
 
+/* Low 32 bit */
+#define EFI_LOW32( a ) (a & 0xFFFFFFFFULL)
+/* High 32 bit */
+#define EFI_HIGH32( a ) (a >> 32)
+
+/*
+ * 64bit division by 10 implemented as multiplication by 1 / 10
+ *
+ * Decimals of one tenth: 0x1 / 0xA = 0x0.19999...
+ */
+#define EFI_TENTH 0x199999999999999A
+static u64 efi_div10(u64 a) {
+	u64 prod;
+	u64 rem;
+	u64 ret;
+
+	ret  = EFI_HIGH32(a) * EFI_HIGH32(EFI_TENTH);
+	prod = EFI_HIGH32(a) * EFI_LOW32(EFI_TENTH);
+	rem  = EFI_LOW32(prod);
+	ret += EFI_HIGH32(prod);
+	prod = EFI_LOW32(a) * EFI_HIGH32(EFI_TENTH);
+	rem += EFI_LOW32(prod);
+	ret += EFI_HIGH32(prod);
+	prod = EFI_LOW32(a) * EFI_LOW32(EFI_TENTH);
+	rem += EFI_HIGH32(prod);
+	ret += EFI_HIGH32(rem);
+	/* Round to nearest integer */
+	if (rem >= (1 << 31))
+		++ret;
+	return ret;
+}
+
 static void efi_signal_event(struct efi_event *event)
 {
 	if (event->signaled)
@@ -234,7 +266,7 @@ void efi_timer_check(void)
 			continue;
 		if (efi_events[i].trigger_type == EFI_TIMER_PERIODIC)
 			efi_events[i].trigger_next +=
-				efi_events[i].trigger_time / 10;
+				efi_events[i].trigger_time;
 		efi_signal_event(&efi_events[i]);
 	}
 	WATCHDOG_RESET();
@@ -243,15 +275,13 @@ void efi_timer_check(void)
 static efi_status_t EFIAPI efi_set_timer(struct efi_event *event, int type,
 					 uint64_t trigger_time)
 {
-	/* We don't have 64bit division available everywhere, so limit timer
-	 * distances to 32bit bits. */
-	u32 trigger32 = trigger_time;
 	int i;
 
-	if (trigger32 < trigger_time) {
-		printf("WARNING: Truncating timer from %"PRIx64" to %x\n",
-		       trigger_time, trigger32);
-	}
+	/*
+	 * The parameter defines a multiple of 100ns.
+	 * We use multiples of 1000ns. So divide by 10.
+	 */
+	trigger_time = efi_div10(trigger_time);
 
 	for (i = 0; i < ARRAY_SIZE(efi_events); ++i) {
 		if (event != &efi_events[i])
@@ -261,18 +291,18 @@ static efi_status_t EFIAPI efi_set_timer(struct efi_event *event, int type,
 
 		switch (type) {
 		case EFI_TIMER_STOP:
-			efi_events[i].trigger_next = -1ULL;
+			event->trigger_next = -1ULL;
 			break;
 		case EFI_TIMER_PERIODIC:
 		case EFI_TIMER_RELATIVE:
-			efi_events[i].trigger_next =
-				timer_get_us() + (trigger32 / 10);
+			efi_events->trigger_next =
+				timer_get_us() + event->trigger_time;
 			break;
 		default:
 			return EFI_INVALID_PARAMETER;
 		}
-		efi_events[i].trigger_type = type;
-		efi_events[i].trigger_time = trigger_time;
+		event->trigger_type = type;
+		event->trigger_time = trigger_time;
 		return EFI_SUCCESS;
 	}
 	return EFI_INVALID_PARAMETER;
-- 
2.13.2

