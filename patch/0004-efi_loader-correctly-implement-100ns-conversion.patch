From d8fc11426abb357ce515b39aca8ec584c645063a Mon Sep 17 00:00:00 2001
From: Heinrich Schuchardt <xypron.glpk@gmx.de>
Date: Sun, 2 Jul 2017 14:48:05 +0200
Subject: [PATCH 1/1] efi_loader: correctly implement 100ns conversion

In efi_set_timer we receive the trigger time in intervals of 100 ns.
We should convert it to intervals of 1000 ns by 64bit division.

The patch supplies function efi_div10 that uses multiplication to
implement the missing 64 bit division.

Signed-off-by: Heinrich Schuchardt <xypron.glpk@gmx.de>
---
 lib/efi_loader/efi_boottime.c | 48 +++++++++++++++++++++++++++++++++++--------
 1 file changed, 39 insertions(+), 9 deletions(-)

diff --git a/lib/efi_loader/efi_boottime.c b/lib/efi_loader/efi_boottime.c
index 3a398fbbf5..1ede608aa6 100644
--- a/lib/efi_loader/efi_boottime.c
+++ b/lib/efi_loader/efi_boottime.c
@@ -82,6 +82,38 @@ efi_status_t efi_exit_func(efi_status_t ret)
 	return ret;
 }
 
+/* Low 32 bit */
+#define EFI_LOW32( a ) (a & 0xFFFFFFFFULL)
+/* High 32 bit */
+#define EFI_HIGH32( a ) (a >> 32)
+
+/*
+ * 64bit division by 10 implemented as multiplication by 1 / 10
+ *
+ * Decimals of one tenth: 0x1 / 0xA = 0x0.19999...
+ */
+#define EFI_TENTH 0x199999999999999A
+static u64 efi_div10(u64 a) {
+	u64 prod;
+	u64 rem;
+	u64 ret;
+
+	ret  = EFI_HIGH32(a) * EFI_HIGH32(EFI_TENTH);
+	prod = EFI_HIGH32(a) * EFI_LOW32(EFI_TENTH);
+	rem  = EFI_LOW32(prod);
+	ret += EFI_HIGH32(prod);
+	prod = EFI_LOW32(a) * EFI_HIGH32(EFI_TENTH);
+	rem += EFI_LOW32(prod);
+	ret += EFI_HIGH32(prod);
+	prod = EFI_LOW32(a) * EFI_LOW32(EFI_TENTH);
+	rem += EFI_HIGH32(prod);
+	ret += EFI_HIGH32(rem);
+	/* Round to nearest integer */
+	if (rem >= (1 << 31))
+		++ret;
+	return ret;
+}
+
 static void efi_signal_event(struct efi_event *event)
 {
 	if (event->signaled)
@@ -256,7 +288,7 @@ void efi_timer_check(void)
 			continue;
 		if (efi_events[i].trigger_type == EFI_TIMER_PERIODIC) {
 			efi_events[i].trigger_next +=
-				efi_events[i].trigger_time / 10;
+				efi_events[i].trigger_time;
 			efi_events[i].signaled = 0;
 		}
 		efi_signal_event(&efi_events[i]);
@@ -267,15 +299,13 @@ void efi_timer_check(void)
 efi_status_t efi_set_timer(struct efi_event *event, int type,
 			   uint64_t trigger_time)
 {
-	/* We don't have 64bit division available everywhere, so limit timer
-	 * distances to 32bit bits. */
-	u32 trigger32 = trigger_time;
 	int i;
 
-	if (trigger32 < trigger_time) {
-		printf("WARNING: Truncating timer from %"PRIx64" to %x\n",
-		       trigger_time, trigger32);
-	}
+	/*
+	 * The parameter defines a multiple of 100ns.
+	 * We use multiples of 1000ns. So divide by 10.
+	 */
+	trigger_time = efi_div10(trigger_time);
 
 	for (i = 0; i < ARRAY_SIZE(efi_events); ++i) {
 		if (event != &efi_events[i])
@@ -290,7 +320,7 @@ efi_status_t efi_set_timer(struct efi_event *event, int type,
 		case EFI_TIMER_PERIODIC:
 		case EFI_TIMER_RELATIVE:
 			event->trigger_next =
-				timer_get_us() + (trigger32 / 10);
+				timer_get_us() + trigger_time;
 			break;
 		default:
 			return EFI_INVALID_PARAMETER;
-- 
2.13.2

